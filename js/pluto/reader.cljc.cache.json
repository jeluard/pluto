["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",["~$read"]],"~:name","~$pluto.reader","~:imports",null,"~:requires",["^ ","~$set","~$clojure.set","~$cljs.tools.reader","^<","^;","^;","~$clojure.tools.reader","^<","~$pluto.utils","^>","~$reference","~$pluto.reader.reference","~$pluto.reader.blocks","^A","~$utils","^>","~$reader","^<","^@","^@","~$blocks","^A"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$valid-namespaces",["^ ","^6","~$pluto.reader/valid-namespaces","~:file","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","~:line",58,"~:column",1,"~:end-line",58,"~:end-column",22,"~:meta",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",58,"^L",6,"^M",58,"^N",22],"~:tag","~$cljs.core/ISet"],"~$parse-value",["^ ","^6","~$pluto.reader/parse-value","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",110,"^L",1,"^M",110,"^N",22,"~:doc","Parse a definition element value.\n   Returns a map defining:\n    * :data the updated value\n    * :permissions \n    * :errors a collection of errors","^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",110,"^L",11,"^M",110,"^N",22,"^T","Parse a definition element value.\n   Returns a map defining:\n    * :data the updated value\n    * :permissions \n    * :errors a collection of errors"],"^P","~$cljs.core/MultiFn"],"~$parse-view",["^ ","~:protocol-inline",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",101,"^L",7,"^M",101,"^N",17,"~:arglists",["~#list",["~$quote",["^Y",[["~$opts","~$o"]]]]]],"^6","~$pluto.reader/parse-view","~:variadic",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",17,"~:method-params",["^Y",[["^[","~$o"]]],"~:protocol-impl",null,"~:arglists-meta",["^Y",[null,null]],"^L",1,"^K",101,"^M",101,"~:max-fixed-arity",2,"~:fn-var",true,"^X",["^Y",["^Z",["^Y",[["^[","~$o"]]]]]],"~$accumulate-reader-exception!",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",26,"^L",8,"^M",26,"^N",36,"~:private",true,"^X",["^Y",["^Z",["^Y",[["~$a","~$ex"]]]]]],"^18",true,"^6","~$pluto.reader/accumulate-reader-exception!","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",36,"^12",["^Y",[["~$a","^19"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",26,"^M",26,"^15",2,"^16",true,"^X",["^Y",["^Z",["^Y",[["~$a","^19"]]]]]],"~$accumulate-reader-error!",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",23,"^L",8,"^M",23,"^N",32,"^18",true,"^X",["^Y",["^Z",["^Y",[["~$a","~$m"]]]]]],"^18",true,"^6","~$pluto.reader/accumulate-reader-error!","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",32,"^12",["^Y",[["~$a","~$m"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",23,"^M",23,"^15",2,"^16",true,"^X",["^Y",["^Z",["^Y",[["~$a","~$m"]]]]]],"^5",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",32,"^L",7,"^M",32,"^N",11,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^T","Reads an extension definition as an EDN string. Valid tags are replaced by associated records.\n   All references (identified by tagged literals) are marked by records.\n   They reference keys in the definition map and are validated and replaced at parse time.\n  \n   No semantic validation is performed at this stage. \n\n   Returns a map defining:\n   * :data the extension definition as a map\n   * :errors a vector of errors map triggered during read"],"^6","~$pluto.reader/read","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",11,"^12",["^Y",[["~$s"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",32,"^M",32,"^15",1,"^16",true,"^X",["^Y",["^Z",["^Y",[["~$s"]]]]],"^T","Reads an extension definition as an EDN string. Valid tags are replaced by associated records.\n   All references (identified by tagged literals) are marked by records.\n   They reference keys in the definition map and are validated and replaced at parse time.\n  \n   No semantic validation is performed at this stage. \n\n   Returns a map defining:\n   * :data the extension definition as a map\n   * :errors a vector of errors map triggered during read"],"~$accumulate-errors",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",72,"^L",7,"^M",72,"^N",24,"^X",["^Y",["^Z",["^Y",[["~$m","~$s"]]]]]],"^6","~$pluto.reader/accumulate-errors","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",24,"^12",["^Y",[["~$m","~$s"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",72,"^M",72,"^15",2,"^16",true,"^X",["^Y",["^Z",["^Y",[["~$m","~$s"]]]]]],"~$valid-extension-keys",["^ ","^6","~$pluto.reader/valid-extension-keys","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",57,"^L",1,"^M",57,"^N",26,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",57,"^L",6,"^M",57,"^N",26],"^P","^Q"],"~$parse-hiccup-element",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",87,"^L",7,"^M",87,"^N",27,"^X",["^Y",["^Z",["^Y",[[["^ ","~:keys",["~$components"],"~:as","^["],"~$o"]]]]]],"^6","~$pluto.reader/parse-hiccup-element","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",27,"^12",["^Y",[["~$p__4036","~$o"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",87,"^M",87,"^15",2,"^16",true,"^X",["^Y",["^Z",["^Y",[[["^ ","^1C",["^1D"],"^1E","^["],"~$o"]]]]]],"~$parse",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",139,"^L",7,"^M",139,"^N",12,"^X",["^Y",["^Z",["^Y",[["^[","~$m"]]]]],"^T","Parse an extension definition map as encapsulated in :data key of the map returned by read.\n   `opts` is a map defining:\n   * `valid-hooks` a map of valid hook definitions\n  \n   Returns a map defining:\n   * :data a map\n   * :permissions a vector of required permissions\n   * :errors a vector of errors maps triggered during parse"],"^6","~$pluto.reader/parse","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",12,"^12",["^Y",[["^[","~$m"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",139,"^M",139,"^15",2,"^16",true,"^X",["^Y",["^Z",["^Y",[["^[","~$m"]]]]],"^T","Parse an extension definition map as encapsulated in :data key of the map returned by read.\n   `opts` is a map defining:\n   * `valid-hooks` a map of valid hook definitions\n  \n   Returns a map defining:\n   * :data a map\n   * :permissions a vector of required permissions\n   * :errors a vector of errors maps triggered during parse"],"~$merge-parsed-value",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",125,"^L",7,"^M",125,"^N",25,"^X",["^Y",["^Z",["^Y",[["^[","~$m","~$k","~$v"]]]]],"^T","Merge result of parse-value into a map.\n   :data is updated to its parsed value\n   :errors are accumulated"],"^6","~$pluto.reader/merge-parsed-value","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",25,"^12",["^Y",[["^[","~$m","~$k","~$v"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",125,"^M",125,"^15",4,"^16",true,"^X",["^Y",["^Z",["^Y",[["^[","~$m","~$k","~$v"]]]]],"^T","Merge result of parse-value into a map.\n   :data is updated to its parsed value\n   :errors are accumulated"],"~$parse-hiccup-children",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",81,"^L",7,"^M",81,"^N",28,"^X",["^Y",["^Z",["^Y",[["^[","~$children"]]]]]],"^6","~$pluto.reader/parse-hiccup-children","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",28,"^12",["^Y",[["^[","^1M"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",81,"^M",81,"^15",2,"^16",true,"^X",["^Y",["^Z",["^Y",[["^[","^1M"]]]]]],"~$merge-errors",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",75,"^L",7,"^M",75,"^N",19,"^X",["^Y",["^Z",["^Y",[["~$m","~$errors"]]]]]],"^6","~$pluto.reader/merge-errors","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",19,"^12",["^Y",[["~$m","^1P"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",75,"^M",75,"^15",2,"^16",true,"^X",["^Y",["^Z",["^Y",[["~$m","^1P"]]]]]],"~$validate-keys",["^ ","^W",null,"^O",["^ ","^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^K",60,"^L",7,"^M",60,"^N",20,"^X",["^Y",["^Z",["^Y",[[["^ ","^1C",["~$valid-hooks"]],"~$s"]]]]]],"^6","~$pluto.reader/validate-keys","^11",false,"^J","/home/julien/Documents/Projects/pluto/src/pluto/reader.cljc","^N",20,"^12",["^Y",[["~$p__4026","~$s"]]],"^13",null,"^14",["^Y",[null,null]],"^L",1,"^K",60,"^M",60,"^15",2,"^16",true,"^X",["^Y",["^Z",["^Y",[[["^ ","^1C",["^1S"]],"~$s"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:errors","~:cause","^O","~:key","~:else","~:invalid-namespaces","~:default","~:value","~:valid-hooks","~:type","~:invalid-hooks","~:components","~:unknown-key","~:unknown-component","~:hierarchy","~:invalid-extension-keys","~:message","~:data"]],"~:order",["^2=","^1[","^2>","^1Z","^O","^25","^26","^2<","^24","^22","^27","^28","^2:","^21","^2;","^23","^29","^20"]],"^T","Overall idea\n   Read time: string to data structure, only tags are replaced by records\n   Parse time: validate all the things, produce hiccup than can be used as is\n   # Read\n     * tags are used as reference to other elements (views, events, queries). At read time they are replaced by records,\n       at parse time they are translated to point to concrete elements (error if non existent).\n       How this translation is done is type dependent (reagent component ref, subscribe call, dispatch, ..)\n   # Parse\n     * properties/children are defined as symbol only, can be defined in element having fn semantic (view, event, ..), are unified at parse time\n     * conditionals are defined as list with symbol as first element. Replaced at parse time by references to corresponding reagent component\n     * let (lexical scoping). No shadowing support (error). Resolve in local scope then delegate to :outer (chain collected from parents)\n     * permissions required are accumulated at parse time\n   # Activate\n    * based on hooks, inject views / trigger events"]